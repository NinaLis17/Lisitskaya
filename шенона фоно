import java.util.Arrays;

public class ShannonFano {

    public static void main(String[] args) {
        double[] probabilities = {0.5, 0.2, 0.1, 0.1, 0.05, 0.05};
        String[] symbols = {"A", "B", "C", "D", "E", "F"};

        // Шаг 1: Вычисление энтропии
        double entropy = calculateEntropy(probabilities);
        System.out.println("Энтропия H(X): " + entropy + " бит/символ");

        // Шаг 2: Построение кода методом Шеннона-Фано
        String[] codes = shannonFano(probabilities, symbols);
        System.out.println("Коды Шеннона-Фано:");
        for (int i = 0; i < codes.length; i++) {
            System.out.println(symbols[i] + ": " + codes[i]);
        }

        // Шаг 3: Определение избыточности и пропускной способности
        double channelCapacity = 2; // символа в секунду
        double averageCodeLength = calculateAverageCodeLength(codes, probabilities);
        double redundancy = averageCodeLength - entropy;
        
        System.out.println("Средняя длина кода: " + averageCodeLength + " бит/символ");
        System.out.println("Избыточность: " + redundancy + " бит/символ");
        System.out.println("Пропускная способность канала: " + channelCapacity + " символов/сек");
    }

    private static double calculateEntropy(double[] probabilities) {
        double entropy = 0.0;
        for (double p : probabilities) {
            if (p > 0) {
                entropy += p * (Math.log(p) / Math.log(2));
            }
        }
        return -entropy;
    }

    private static String[] shannonFano(double[] probabilities, String[] symbols) {
        int n = probabilities.length;
        String[] codes = new String[n];
        shannonFanoRec(probabilities, symbols, codes, 0, n);
        return codes;
    }

    private static void shannonFanoRec(double[] probabilities, String[] symbols, String[] codes, int start, int end) {
        if (start >= end) return;

        // Если один символ, назначаем ему код
        if (start == end - 1) {
            codes[start] = "";
            return;
        }

        double totalProbability = 0;
        for (int i = start; i < end; i++) {
            totalProbability += probabilities[i];
        }

        double cumulativeProbability = 0;
        int splitIndex = start;
        
        // Найти точку разделения
        while (splitIndex < end && cumulativeProbability + probabilities[splitIndex] < totalProbability / 2) {
            cumulativeProbability += probabilities[splitIndex];
            splitIndex++;
        }

        // Назначить коды
        for (int i = start; i < splitIndex; i++) {
            codes[i] = (codes[i] == null ? "" : codes[i]) + "0";
        }
        for (int i = splitIndex; i < end; i++) {
            codes[i] = (codes[i] == null ? "" : codes[i]) + "1";
        }

        // Рекурсивно применить к подмассивам
        shannonFanoRec(probabilities, symbols, codes, start, splitIndex);
        shannonFanoRec(probabilities, symbols, codes, splitIndex, end);
    }

    private static double calculateAverageCodeLength(String[] codes, double[] probabilities) {
        double averageLength = 0.0;
        for (int i = 0; i < codes.length; i++) {
            averageLength += probabilities[i] * codes[i].length();
        }
        return averageLength;
    }
}
